=head1 NOMBRE

perlrun - cómo ejecutar el intérprete de Perl

=head1 SINOPSIS

B<perl>	S<[ B<-sTtuUWX> ]>
	S<[ B<-hv> ] [ B<-V>[:I<var_config>] ]>
	S<[ B<-cw> ] [ B<-d>[B<t>][:I<depurador>] ] [ B<-D>[I<número/lista>] ]>
	S<[ B<-pna> ] [ B<-F>I<patrón> ] [ B<-l>[I<octal>] ] [ B<-0>[I<octal/hexadecimal>] ]>
	S<[ B<-I>I<dir> ] [ B<-m>[B<->]I<módulo> ] [ B<-M>[B<->]I<'módulo...'> ] [ B<-f> ]>
	S<[ B<-C [I<número/lista>] >]>
	S<[ B<-S> ]>
	S<[ B<-x>[I<dir>] ]>
	S<[ B<-i>[I<extensión>] ]>
	S<[ [B<-e>|B<-E>] I<'comando'> ] [ B<--> ] [ I<archivo_programa> ] [ I<argumento> ]...>

=head1 DESCRIPCIÓN

La forma normal de ejecutar un programa de Perl es haciéndolo directamente ejecutable, o bien pasando el nombre del código fuente como un argumento en la línea de comandos.  (Un entorno Perl interactivo también está disponible -vea L<perldebug> para más detalles de cómo hacer esto-).
En el arranque, Perl busca por su programa en uno de los siguientes lugares:

=over 4

=item 1.

Especificado línea a línea por medio de las opciones B<-e> o B<-E> en la línea de comandos.

=item 2.

Contenido en el archivo especificado por el primer nombre de archivo en la línea de comandos.
(Tenga en cuenta que los sistemas que soporten la notación C<#!>, invocan a los intérpretes de esta manera. Vea L<Emplazamiento de Perl>).

=item 3.

Pasado implícitamente a través de la entrada estándar.  Esto sólo funciona si no hay nombres de archivo como argumentos -para pasar argumentos a un programa que lee desde el STDIN debe, explícitamente, especificar un "-" para el nombre del programa-.

=back

Con los métodos 2 y 3, Perl inicia el análisis del archivo de entrada desde el comienzo, a menos que haya especificado una opción B<-x>, en cuyo caso escanea por la primera línea que comience por C<#!> y contenga la palabra "perl", y arrancará desde allí.  Esto es útil para ejecutar un programa incorporado en un correo grande.  (En este caso se indicará el final del programa, utilizando el I<token> C<__END__>).

La línea C<#!> es siempre examinada para buscar las opciones mientras la línea está siendo analizada.  Por lo tanto, si está en una máquina que sólo permite un argumento con la línea C<#!>, o peor aún, ni siquiera reconoce la línea C<#!>, todavía puede obtener un comportamiento consistente de las opciones independientemente de cómo Perl haya sido invocado, incluso si B<-x> fue utilizado para encontrar el inicio del programa.

Debido a que, históricamente, algunos sistemas operativos cortan, silenciosamente, la interpretación de la línea C<#!> después de 32 caracteres, algunas opciones puede ser pasadas a la línea de comandos, y algunas otras, no; incluso se podría obtener un "-" sin su carácter, si no tiene cuidado.
Probablemente querrá asegurarse de que todos las opciones caigan antes del límite de 32 caracteres.  La mayoría de las opciones, en realidad, no les importa si son procesadas ​​de forma redundante, pero obtener un "-" en lugar de una opción completa podría hacer que Perl intente ejecutar la entrada estándar, en lugar de su programa.  Y una opción B<-I> parcial también podría causar resultados extraños.

Algunas opciones son importantes por si son procesadas dos veces, como por ejemplo, combinaciones de B<-l> y B<-0>.  Puede poner todos las opciones después del límite de 32 caracteres (si procede), o reemplazar el uso de B<-0>I<dígitos> por C<BEGIN{ $/ = "\0dígitos"; }>.

El análisis de las opciones C<#!> empieza cuando se ha mencionado a "perl", en la línea.
Las secuencias "-*" y "- " son, específicamente, ignoradas, así que podría, si quisiera, escribir cosas como

    #!/bin/sh
    #! -*-perl-*-
    eval 'exec perl -x -wS $0 ${1+"$@"}'
        if 0;

para permitir a Perl ver la opción B<-p>.

Un truco similar hay con el programa I<env>, si lo tiene instalado.

    #!/usr/bin/env perl

Los ejemplos anteriores usan una ruta relativa al intérprete perl, accediendo al primero que se encuentre en la ruta del usuario, sin fijarse en qué versión sea.  Si necesita una versión específica de Perl, por ejemplo, la perl5.14.1, debe colocarla directamente en la ruta de la línea C<#!>.

Si la línea C<#!> no contiene la palabra "perl" ni la palabra "indir", el programa nombrado después de C<#!> es ejecutado en lugar del intérprete de Perl.  Esto es algo extraño, pero ayuda a personas en máquinas que no pueden trabajar con C<#!>, porque ellas pueden indicar a un programa que su SHELL es F</usr/bin/perl>, y Perl, entonces, despachará, por ellos, el programa al intérprete correcto.

Después de localizar a su programa, Perl compila el programa entero a una forma interna.  Si existe algún error de compilación, ni se intenta la ejecución del programa.  (Esto es muy distinto del típico script shell, que se ejecutará sin pensarlo hasta encontrar el primer error de sintaxis).

Si el programa es sintácticamente correcto, es ejecutado.  Si el programa se ejecuta hasta el final sin llegar a un operador exit() o die(), se ejecuta un implícito C<exit(0)> para indicar un completado exitoso.

=head2 #! y entrecomillado en sistemas distintos del Unix
X<hashbang> X<#!>

La técnica C<#!> del Unix puede ser simulada en otros sistemas:

=over 4

=item OS/2

Ponga

    extproc perl -S -sus_modificadores

como primera línea en el archivo C<*.cmd> (B<-S> si sale un error en el manejo de `extproc' del cmd.exe).

=item MS-DOS

Cree un archivo batch para ejecutar su programa, y codifique en él un C<ALTERNATE_SHEBANG> (vea el archivo F<dosish.h> en el código fuente de su distribución para obtener más información).

=item Win95/NT

La instalación Win95/NT, cuando se usa el instalador de ActiveState para Perl, modificará el Registro para asociar la extensión F<.pl> con el intérprete perl.  Si instala Perl por otros medios (incluyendo la generación del código fuente), puede modificar usted mismo el Registro de Windows.  Tenga en cuenta que esto significa que ya no podrá diferenciar a un programa Perl ejecutable de un archivo de biblioteca Perl.

=item VMS

Ponga

 $ perl -mysw 'f$env("procedure")' 'p1' 'p2' 'p3' 'p4' 'p5' 'p6' 'p7' 'p8' !
 $ exit++ + ++$status != 0 and $exit = $status = undef;

al comienzo del programa, donde B<-mysw> es cualquier conjunto de opciones que quiera pasar a Perl.  Ahora puede invocar el programa directamente, diciendo C<perl programa>, o como un procedimiento DCL, diciendo C<@programa> (o, implícitamente vía F<DCL$PATH> usando simplemente el nombre del programa).

Esta llamada es más difícil de recordar, pero Perl se la mostrará si dice C<perl "-V:startperl">.

=back

Los intérpretes de comando en sistemas Unix tienen diferentes ideas sobre el entrecomillado en los shells Unix.  Tendrá que aprender los caracteres especiales de su intérprete de comandos (C<*>, C<\> y C<"> son los más comunes) y la forma de proteger el espacio en blanco y estos caracteres para ejecutar programas de una sola línea (vea L<-e|/-e línea de comando> más abajo).

En algunos sistemas, quizás tenga que cambiar las comillas simples por las dobles, algo que I<no> debe hacer en sistemas Unix o Plan 9.  Quizás tenga que cambiar un simple % a un %%.

Por ejemplo:

    # Unix
    perl -e 'print "Hola a todos\n"'

    # MS-DOS, etc.
    perl -e "print \"Hola a todos\n\""

    # VMS
    perl -e "print ""Hola a todos\n"""

El problema es que nada de esto es fiable: depende del comando e es incluso posible que nada funcione.  Si I<4DOS> fuera el shell de comandos, esto serviría mejor:

    perl -e "print <Ctrl-x>"Hola a todos\n<Ctrl-x>""

B<CMD.EXE> en Windows NT tomó mucha de las funcionalidades estándar de Unix cuando nadie estaba mirando, pero intente encontrar documentación sobre sus reglas de entrecomillado.

No existe una solución general para todo esto.  Es un completo enredo.

=head2 Emplazamiento de Perl
X<perl, emplazamiento del intérprete>

Parce obvio decirlo, pero Perl solo es útil cuando los usuarios pueden encontrarlo fácilmente.  Cuando sea posible, sería bueno que tanto F</usr/bin/perl> como F</usr/local/bin/perl> sean enlaces simbólicos al binario real.  Si eso no se puede hacer, se solicita a los administradores del sistema que pongan (enlaces simbólicos) a perl y sus utilerías asociadas en un directorio que esté normalmente en el PATH del usuario, o en algún otro obvio y conveniente lugar.

En esta documentación, C<#!/usr/bin/perl> en la primera línea del programa aparecerá sin importar qué método funcione es su sistema.  Se le aconseja que use una ruta específica si le interesa usar una versión específica.

    #!/usr/local/bin/perl5.14

o si solo quiere ejecutar una cierta versión, coloca una instrucción como esta al principio de su programa:

    use 5.014;

=head2 Opciones de comando
X<perl, opciones comando> X<opciones comando>

Como con todos los comandos estándares, una opción de un sólo carácter puede ser agrupado con la siguiente opción, si la hubiera.

    #!/usr/bin/perl -spi.orig	# lo mismo que -s -p -i.orig

Un C<--> señala el final de las opciones y desactiva el procesamiento de las siguientes opciones. Cualesquiera argumentos después de los C<--> se tratan como nombres de archivos y argumentos.

Las opciones son:

=over 5

=item B<-0>[I<octal/hexadecimal>]
X<-0> X<$/>

especifica el delimitador de registros de entrada (C<$/>) como un número en octal o hexadecimal.  Si no hay dígitos, el separador será el carácter nulo.  Otras opciones pueden preceder o seguir a los dígitos.  Por ejemplo, si tiene una versión de I<find> que puede imprimir nombres de archivos terminados con un carácter nulo, puede decir algo esto:

    find . -name '*.orig' -print0 | perl -n0e unlink

El valor especial 00 hará que Perl succione archivos en modo párrafo.
Cualquier valor igual o superior a 0400 hará que Perl succione todo el archivo, pero, por convención, para este propósito se usa de forma normal el valor 0777.

También puede especificar el carácter separador usando notación hexadecimal: B<-0xI<HHH...>>, donde C<I<H>> son dígitos hexadecimales válidos.  A diferencia de con la forma octal, ésta puede ser usada para especificar cualquier carácter Unicode, incluso lo que están más allá de 0xFF.  Así que si I<verdaderamente> quiere usar un separador de registro 0777, especifíquelo como B<-0x1FF>.  (Esto significa que no puede usar la opción B<-x> con un nombre de directorio que consista en dígitos hexadecimales, o sino, Perl pensará que ha especificado un número hex relativo a B<-0>).

=item B<-a>
X<-a> X<autosplit>

activa el modo de auto división, cuando se usa junto con B<-n> o B<-p>.  Se realiza un implícito comando split al array @F como primera tarea que se realiza dentro del implícito bucle while creado por B<-n> o B<-p>.

    perl -ane 'print pop(@F), "\n";'

es equivalente a

    while (<>) {
	@F = split(' ');
	print pop(@F), "\n";
    }

Se puede especificar un delimitador alternativo usando B<-F>.

B<-a> activa implícitamente B<-n>.

=item B<-C [I<número/lista>]>
X<-C>

La opción B<-C> controla alguna de las características Unicode en Perl.

A partir de 5.8.1, el B<-C> puede ser seguido tanto por un número como una lista de letras de opciones.  Estas letras, sus valores numéricos, y efectos, son como sigue; listar las letras es lo mismo que sumar los números.

    I     1   STDIN es asumido que está en UTF-8
    O     2   STDOUT estará en UTF-8
    E     4   STDERR estará en UTF-8
    S     7   I + O + E
    i     8   UTF-8 es la capa PerlIO por defecto para los flujos de entrada
    o    16   UTF-8 es la capa PerlIO por defecto para los flujos de salida
    D    24   i + o
    A    32   se espera que los elementos de @ARGV sean cadenas codificadas
              en UTF-8
    L    64   normalmente, "IOEioA" es incondicional, pero L les hace
              condicionales a las variables de entorno de la configuración regional
              (los LC_ALL, LC_CTYPE y LANG, en orden de
              precedencia decreciente) -- si las variables indican
              UTF-8, entonces queda activo el seleccionado "IOEioA"
    a   256   Pone ${^UTF8CACHE} a -1, para ejecutar en modo depuración
              el código almacenado.

=for documentando_lo_indocumentado
perl.h ofrece W/128 como PERL_UNICODE_WIDESYSCALLS "/* por Sarathy */"

=for todo
perltodo menciona Unicode en %ENV y en los nombres de archivo. Supongo que serán las opciones e y f (o F).

Por ejemplo, B<-COE> y B<-C6> activarán el tratamiento UTF-8 tanto en STDOUT como en STDERR.  Repetir letras solo es redundante, ni acumulativo ni intercambia el sentido.

Las opciones C<io> quieren decir que cualquier subsecuente open() (o similares operaciones de E/S) en el actual ámbito del archivo tendrá aplicado una implícita capa PerlIO C<:utf8>, en otras palabras, se espera UTF-8 en cualquier flujo de entrada, y UTF-8 es producido en cualquier flujo de salida.  Esto queda marcado como por defecto, mientras que las capas explícitas en open() y con binmode() se pueden manipular los flujos de la forma usual.

Un solitario B<-C> (no seguido por ningún número ni lista de opciones), o la cadena vacía C<""> para la variable de entorno C<PERL_UNICODE>, tiene el mismo efecto que B<-CSDL>.  En otras palabras, los identificadores de archivo estándares de E/S y la capa por defecto para C<open()> están en modo UTF I<pero> solo si las variables de entorno de configuración local indican que se está en un entorno local UTF-8.  Este comportamiento sigue el I<implícito> (y problemático) comportamiento de UTF-8 de Perl 5.8.0.
(Vea L<perl581delta/UTF-8 ya no está predeterminado bajo configuraciones regionales UTF-8>).

Puede usar B<-C0> (o C<"0"> para C<PERL_UNICODE>) para desactivar explícitamente todas las características Unicode anteriores.

La variable mágica de solo lectura C<${^UNICODE}> refleja el valor numérico de este parámetro.  Esta variable se activa durante el arranque de Perl y, por lo tanto, es de solo lectura.  Si quiere efectos en tiempo de ejecución, use el open() de tres argumentos (vea L<perlfunc/open>), el binmode() de dos argumentos (vea L<perlfunc/binmode>), y el pragma C<open> (vea L<open>).

(En Perl anteriores a 5.8.1, la opción B<-C> solo era una opción solo Win32 que activaba el uso de las "wide system call" de la API de Win32 relativo a la codificación Unicode.
Esta característica, sin embargo, y en la práctica, no era usada, por lo que esta opción ha sido "reciclada").

B<Nota:> Desde perl 5.10.1, si la opción B<-C> es usada en la línea C<#!>, también debe ser especificada en la línea de comando, debido a que los flujos estándar son inicializados en ese punto, en la ejecución del intérprete perl.
También puede usar binmode() para establecer la codificación de un flujo de E/S.

=item B<-c>
X<-c>

hace que Perl comprueba la sintaxis del programa y salga sin ejecutarlo.  Realmente, I<ejecutará> los bloques C<BEGIN>, C<UNITCHECK>, o C<CHECK> y cualquier instrucción C<use>: se les considera que ocurren fuera de la ejecución de su programa.  Bloques C<INIT> y C<END>, sin embargo, serán obviados.

=item B<-d>
X<-d> X<-dt>

=item B<-dt>

ejecuta el programa bajo el depurador Perl.  Vea L<perldebug>.
Si se ha especificado B<t>, indica al depurador que se depurarán los hilos de ejecución usados en el código.

=item B<-d:>I<MOD[=bar,baz]>
X<-d> X<-dt>

=item B<-dt:>I<MOD[=bar,baz]>

ejecuta el programa bajo el control de una depuración, perfilado, o trazado de un módulo instalado como C<Devel::I<MOD>>. Ej., B<-d:DProf> ejecuta el programa usando el perfilador C<Devel::DProf>.  Igual que con la opción B<-M>, las opciones se pasan al paquete C<Devel::I<MOD>> donde serán recibidas e interpretadas por la rutina C<Devel::I<MOD>::import>.  De nuevo, como en B<-M>, use -B<-d:-I<MOD>> para llamar a C<Devel::I<MOD>::unimport> en lugar de import.  La lista de opciones separada por comas debe seguir al carácter C<=>.  Si se ha especificado B<t>, indica al depurador que se depurarán los hilos de ejecución usados en el código.  Vea L<perldebug>.

=item B<-D>I<letras>
X<-D> X<DEBUGGING> X<-DDEBUGGING>

=item B<-D>I<número>

activa opciones de depuración.  Para mirar cómo se ejecuta su programa, use B<-Dtls>.  (Esto funciona solo si el soporte para depuración fue compilado en su Perl).  Otro valor interesante es B<-Dx>, que lista el árbol de sintaxis compilado.  Y B<-Dr> muestra las expresiones regulares compiladas; el formato de salida es explicado en L<perldebguts>.

Como alternativa, especifique un número en lugar de una lista de letras (ej., B<-D14> es equivalente a B<-Dtls>):

        1  p  I<Tokenización> y análisis (con v, muestra la pila de análisis)
        2  s  Volcados de la Pila (con v, muestra todas las pilas)
        4  l  Procesado de las pilas de contexto (bucles)
        8  t  Trazado de la ejecución
       16  o  Resolución de métodos y sobrecarga
       32  c  Conversiones cadena/número
       64  P  Imprime información de perfilado y el estado de la entrada del archivo fuente
      128  m  Reserva de memoria y de SV
      256  f  Procesado de formatos
      512  r  Análisis y ejecución de expresiones regulares
     1024  x  Volcado del árbol sintáctico
     2048  u  Comprobaciones de contaminación
     4096  U  No oficial, para hackeo de usuarios (reservado para uso privado,
              no distribuible)
     8192  H  Volcado de Hash -- usurpa values()
    16384  X  Reserva del Scratchpad
    32768  D  Limpieza
    65536  S  Reserva de Op slab
   131072  T  I<Tokenización>
   262144  R  Incluye el contador de referencias de las variables volcadas (ej. cuando
              se usa -Ds)
   524288  J  muestra s,t,P-debug (no salta afuera) en códigos de operación dentro del
              package DB
  1048576  v  Verboso: usar junto con otros indicadores
  2097152  C  Copiar En Escritura
  4194304  A  Comprueba la consistencia en las estructuras internas
  8388608  q  silencio - actualmente sólo suprime el "EXECUTING"
              mensaje
 16777216  M  traza la resolución de la coincidencia inteligente
 33554432  B  vuelca las definiciones de suBrutinas, incluyendo los Bloques especiales
              como BEGIN
 67108864  L  traza de información relacionada con Locale; lo que se consigue es muy
              sujeto a cambio

Todas estos indicadores requieren B<-DDEBUGGING> cuando compile el ejecutable Perl (pero vea C<:opd> en L<Devel::Peek> o L<re/modo 'debug'> que puede cambiar esto).
Vea el archivo F<INSTALL> en la distribución del código fuente para saber cómo hacerlo.  Este indicador se activa automáticamente si incluye la opción B<-g> cuando C<Configure> pregunte sobre indicadores para el optimizador/depurador.

Si solo está intentando imprimir cada línea del código Perl que está ejecutando, de la misma forma que C<sh -x> se ofrece para los script del shell, no puede usar la opción B<-D> con Perl.  En lugar de eso

  # Si tiene una utilidad "env"
  env PERLDB_OPTS="NonStop=1 AutoTrace=1 frame=2" perl -dS programa

  # Sintaxis Bourne shell
  $ PERLDB_OPTS="NonStop=1 AutoTrace=1 frame=2" perl -dS programa

  # Sintaxis csh
  % (setenv PERLDB_OPTS "NonStop=1 AutoTrace=1 frame=2"; perl -dS programa)

Vea L<perldebug> para más detalles y variaciones.

=item B<-e> I<línea de comando>
X<-e>

puede ser usado para entrar un programa de una línea.  Si se indica B<-e>, Perl no mirará por un nombre de archivo en la lista de argumentos.  Se pueden indicar múltiples comandos B<-e> para generar un script multilínea.  Asegúrese de usar caracteres de punto y coma tal y como haría con un programa normal.

=item B<-E> I<línea de comandos>
X<-E>

se comporta igual que B<-e>, excepto que, implicitamente, activa todas las características opcionales (en la unidad de compilación principal). Ver L<feature>.

=item B<-f>
X<-f> X<sitecustomize> X<sitecustomize.pl>

Desactiva la ejecución de F<$Config{sitelib}/sitecustomize.pl> en el arranque.

Se puede compilar Perl para que, por defecto, intentará ejecutar F<$Config{sitelib}/sitecustomize.pl> en el arranque (en el bloque BEGIN).
Esto es un enganche que permite al administrador del sistema personalizar el comportamiento de Perl.
Puede, por ejemplo, ser usado para añadir entradas al array @INC para hacer que Perl busque módulos en lugares no estándares.

Perl realmente inserta el siguiente código:

    BEGIN {
        do { local $!; -f "$Config{sitelib}/sitecustomize.pl"; }
            && do "$Config{sitelib}/sitecustomize.pl";
    }

Debido a que es un C<do> real (no un C<require>), F<sitecustomize.pl> no retorna un valor verdadero. El código se ejecuta en el paquete C<main>, en su propio ámbito léxico. Sin embargo, el el script muere, C<$@> no será actualizado.

El valor de C<$Config{sitelib}> también está determinado en el código C, no leído desde C<Config.pm>, que no es cargado.

El código es ejecutado I<muy> prontamente. Por ejemplo, cualquier cambio hecho a C<@INC> se mostrará en la salida de `perl -V`. Naturalmente, los bloques C<END> serán igualmente ejecutados muy tardíamente.

Para determinar en tiempo de ejecución si esta capacidad ha sido compilada en su perl, puede comprobar el valor de C<$Config{usesitecustomize}>.

=item B<-F>I<patrón>
X<-F>

especifica el patrón a split para la opción B<-a>. El patrón puede estar rodeado de C<//>, C<""> o C<''>, o de lo contrario se pondrá entre comillas simples. Puede usar espacio en blanco literal dentro del patrón.

B<-F> activa implícitamente tanto B<-a> como B<-n>.

=item B<-h>
X<-h>

imprime un resumen de las opciones.

=item B<-i>[I<extensión>]
X<-i> X<in situ>

especifica que los archivos procesados por la construcción C<E<lt>E<gt>> han de ser editados in situ.  Lo hace renombrando el archivo de entrada, abriendo el archivo de salida con el nombre original, y seleccionando este archivo de salida como el de por defecto para las instrucciones print().  La extensión, si es suministrada, es usada para modificar el nombre del viejo archivo para hacer una copia de seguridad, siguiendo estas reglas:

Si no se suministra ninguna extensión, y su sistema lo soporta, el I<archivo> original se mantiene abierto, sin nombre, mientras que la salida se redirige a un archivo nuevo con el I<nombre> original.  Cuándo perl salga, limpiamente o no, se elimina el I<archivo> original.

Si la extensión no contiene un C<*>, entonces es añadida al final del nombre de archivo actual como sufijo.  Si la extensión contiene uno o más caracteres C<*>, entonces cada C<*> es reemplazado por el nombre del archivo actual.  En términos Perl, se podría pensar que se está haciendo esto:

    ($backup = $extension) =~ s/\*/$nombre_archivo/g;

Esto le permite añadir un prefijo al archivo de copia de seguridad, en vez de (o además de)
un sufijo:

 $ perl -pi'orig_*' -e 's/bar/baz/' fileA  # copia de seguridad a
                                           # 'orig_fileA'

O incluso para colocar copias de seguridad de los archivos originales en otro directorio (suponiendo que el directorio ya existe):

 $ perl -pi'old/*.orig' -e 's/bar/baz/' fileA  # copia de seguridad a
                                               # 'old/fileA.orig'

Este conjunto de una-líneas son equivalentes:

 $ perl -pi -e 's/bar/baz/' fileA          # sobrescribe el archivo actual
 $ perl -pi'*' -e 's/bar/baz/' fileA       # sobrescribe el archivo actual

 $ perl -pi'.orig' -e 's/bar/baz/' fileA   # copia de seguridad a 'fileA.orig'
 $ perl -pi'*.orig' -e 's/bar/baz/' fileA  # copia de seguridad a 'fileA.orig'

Desde el shell, decir

    $ perl -p -i.orig -e "s/foo/bar/; ... "

es lo mismo que usar el programa:

    #!/usr/bin/perl -pi.orig
    s/foo/bar/;

que es equivalente a

    #!/usr/bin/perl
    $extension = '.orig';
    LINE: while (<>) {
	if ($ARGV ne $oldargv) {
	    if ($extension !~ /\*/) {
		$backup = $ARGV . $extension;
	    }
	    else {
		($backup = $extension) =~ s/\*/$ARGV/g;
	    }
	    rename($ARGV, $backup);
	    open(ARGVOUT, ">$ARGV");
	    select(ARGVOUT);
	    $oldargv = $ARGV;
	}
	s/foo/bar/;
    }
    continue {
	print;	# esto imprime el nombre de archivo original
    }
    select(STDOUT);

excepto que la opción B<-i> no necesita comparar $ARGV a $oldargv para saber cuándo el nombre de archivo ha cambiado.  Aun así, usa ARGVOUT para el identificador de archivo seleccionado.  Tenga en cuenta que STDOUT es restaurado como el identificador de archivo por defecto, después del bucle.

Como se muestra arriba, Perl crea el archivo de copia de seguridad tanto si ha ocurrido un cambio en la salida, como si no.  Así que esto es justo una manera elegante de copiar archivos:

    $ perl -p -i'/alguna/ruta/archivos/*' -e 1 archivo1 archivo2 archivo3...
o
    $ perl -p -i'.orig' -e 1 archivo1 archivo2 archivo3...

Puede utilizar C<eof> sin paréntesis para localizar el fin de cada archivo de entrada, en caso de que quiera añadir a cada archivo, o reiniciar la numeración de líneas (vea ejemplo en L<perlfunc/eof>).

Si, para un archivo dado, Perl es incapaz de crear el archivo de copia de seguridad cuando se ha especificado en la extensión, entonces saltará ese archivo y continuará con el siguiente (si existe).

Para una discusión de las cuestiones que rodean a los permisos de archivo y B<-i>, vea L<perlfaq5/¿Por qué Perl me deja eliminar archivos de solo lectura?  ¿Por qué -i sobrescribe archivos protegidos?  ¿Esto no es un error de Perl?>.

No puede usar B<-i> para crear directorios o quita extensiones a los archivos.

Perl no expande C<~> en los nombres de archivo, lo cual está bien, desde que algunos amigos lo usan para sus archivos de copia de seguridad:

    $ perl -pi~ -e 's/foo/bar/' archivo1 archivo2 archivo3...

Tenga en cuenta que debido a que B<-i> renombra o elimina el archivo original antes de crear un archivo nuevo con el mismo nombre, los enlaces tipo Unix, blandos y duros, no serán preservados.

Finalmente, la opción B<-i> no impide la ejecución cuándo no se indica ningún archivo en la línea de comandos.  En este caso, no se realiza ninguna copia de seguridad (el archivo original no puede, naturalmente, ser determinado) y el procesamiento procede de STDIN a STDOUT, que es lo esperado.

=item B<-I>I<directorio>
X<-I> X<@INC>

Los directorios especificados por B<-I> son antepuestos a las rutas de búsqueda de módulos (C<@INC>).

=item B<-l>[I<núm_octal>]
X<-l> X<$/> X<$\>

habilita el procesamiento automático de fin de línea.  Tiene dos efectos separados.  Primero, automáticamente chomps C<$/> (el separador de registros de entrada) cuándo es utilizado con B<-n> o B<-p>.  Segundo, asigna C<$\> (el separador de registros de salida) al valor I<núm_oct>, de modo que cualesquiera instrucciones de impresión tendrán este separador añadido.
Si se omite I<núm_oct>, C<$\> toma el valor actual de C<$/>.  Por ejemplo, para recortar líneas a 80 columnas:

    perl -lpe 'substr($_, 80) = ""'

Tenga en cuenta que la asignación C<$\ = $/> se realiza cuando la opción es procesada, así que el separador de registro de entrada puede ser diferente del separador de registros de salida si la opción B<-l> es seguida por una opción B<-0>:

    gnufind / -print0 | perl -ln0e 'print "encontrado $_" if -p'

Esto pone C<$\> a un carácter de nueva línea y luego pone C<$/> al carácter nulo.

=item B<-m>[B<->]I<módulo>
X<-m> X<-M>

=item B<-M>[B<->]I<módulo>

=item B<-M>[B<->]I<'módulo ...'>

=item B<-[mM]>[B<->]I<módulo=arg[,arg]...>

B<-m>I<módulo> ejecuta C<use> I<módulo> C<();> antes de ejecutar su programa.

B<-M>I<módulo> ejecuta C<use> I<módulo> C<;> antes de ejecutar su programa.  Puede utilizar comillas para añadir código extra después del nombre del módulo, p. ej., C<'-MI<MÓDULO> qw(foo bar)'>.

Si el primer carácter después de B<-M> o B<-m> es un guion (B<->) entonces el 'use' es reemplazado por un 'no'.

Un poco de endulzamiento sintáctico predefinido puede ayudarle para decir B<-mI<MÓDULO>=foo,bar> o B<-MI<MÓDULO>=foo,bar> como una forma abreviada de B<'-MI<MÓDULO> qw(foo bar)'>.  Esto evita la necesidad de usar comillas cuando se importan símbolos.  El código real generado por B<-MI<MÓDULO>=foo,bar> es C<use módulo split(/,/,q{foo,bar})>.  Note que la forma C<=> quita la distinción entre B<-m> y B<-M>, es decir, B<-mI<MODULO>=foo,bar> es lo mismo que B<-MI<MODULO>=foo,bar>.

Una consecuencia de esto es que B<-MI<MÓDULO>=número> nunca hace un control de versión, a no ser que C<I<MÓDULO>::import()> tenga instalado un control de versión, lo cual podría pasar, por ejemplo, si I<MÓDULO> hereda de L<Exporter>.

=item B<-n>
X<-n>

hace que Perl asuma el bucle siguiente alrededor de su programa, el cual hace iteraciones sobre los nombres de archivo de los argumentos, algo como I<sed -n> o I<awk>:

  LINEA:
    while (<>) {
	...		# su programa va aquí
    }

Note que las líneas, por defecto, no son impresas.  Vea L</-p> para tener las líneas impresas.  Si un archivo nombrado por un argumento no puede ser abierto por alguna razón, Perl se lo advierte y pasa al archivo siguiente.

También tenga en cuenta que C<< <> >> pasa los argumentos de la línea de comandos a L<perlfunc/open>, el cual, no necesariamente, les interpreta como nombres de archivo.
Vea L<perlop> para las posibles implicaciones de seguridad.

Aquí hay una manera eficaz de eliminar todos los archivos que no hayan sido modificados durante la última semana:

    find . -mtime +7 -print | perl -nle unlink

Esto es más rápido que utilizar la opción B<-exec> de I<find> porque no tiene que arrancar un proceso en cada nombre de archivo encontrado.  Adolece del error de perder los caracteres de nueva línea en los nombres de las rutas de archivos, que puede arreglar si sigue el ejemplo que hay en B<-0>.

Los bloques C<BEGIN> y C<END> pueden ser usados para capturar el control antes de o después del
bucle de programa implícito, como se hace en I<awk>.

=item B<-p>
X<-p>

hace que Perl asuma el bucle siguiente alrededor de su programa, el cual hace iteraciones sobre los nombres de archivo de los argumentos, algo como I<sed>:


  LINEA:
    while (<>) {
	...		# su programa va aquí
    } continue {
	print or die "-p destino: $!\n";
    }

Si un archivo nombrado por un argumento no puede ser abierto por alguna razón, Perl se lo advierte y pasa al archivo siguiente.  Note que las líneas son impresas automáticamente.  Un error que ocurra durante la impresión es tratado como fatal.  Para suprimir la impresión use la opción B<-n>.  Una opción B<-p> sobrescribe una B<-n>.

Los bloques C<BEGIN> y C<END> pueden ser usados para capturar el control antes de o después del bucle implícito, como se hace en I<awk>.

=item B<-s>
X<-s>

habilita un rudimentario análisis de opciones en la línea de comando después del nombre de programa pero antes de cualquier argumento de nombre de archivo (o antes de un argumento B<-->).  Cualquier opción encontrada allí es eliminada de @ARGV y se pone en la correspondiente variable del programa Perl.  El programa siguiente imprime "1" si el programa es invocado con una opción B<-xyz>, y "abc" si es invocado con B<-xyz=abc>.

    #!/usr/bin/perl -s
    if ($xyz) { print "$xyz\n" }

Tenga en cuenta que una opción como B<--help> crea la variable C<${-help}>, el cual no es acorde con C<use strict "refs">.  También, cuándo use esta opción en un guión con las advertencias habilitadas, puede obtener avisos espurios de la forma "utilizado sólo una vez (I<used only once>)".

=item B<-S>
X<-S>

hace que Perl use la variable de entorno PATH para buscar el programa, a no ser que el nombre del programa contenga separadores de ruta.

En algunas plataformas, esto también hace que Perl añada sufijos al nombre del archivo mientras lo busca.  Por ejemplo, en plataformas Win32, los sufijos ".bat" y ".cmd" son añadidos si falla la localización del nombre original, y si el nombre no termina realmente en uno de estos sufijos.  Si su Perl fue compilado con C<DEBUGGING> activado, usando la opción B<-Dp> hace que Perl muestre el progreso de búsqueda.

Típicamente esto es lo que se usa para emular el arranque C<#!> en plataformas que no soportan C<#!>.  Es también conveniente que cuando se depura un guión que usa C<#!>, y es normalmente encontrado por los mecanismos de búsqueda del shell en $PATH.

Este ejemplo funciona en muchas plataformas que tienen un shell compatible con Bourne shell:

    #!/usr/bin/perl
    eval 'exec /usr/bin/perl -wS $0 ${1+"$@"}'
	    if $ejecutando_bajo_algun_shell;

El sistema ignora la primera línea y alimenta el programa a F</bin/sh>, el cual procede a probar a ejecutar el programa Perl como un guión de shell.
El shell ejecuta la segunda línea como un comando shell normal, y así arranca el intérprete Perl.  En algunos sistemas, $0 no siempre contiene la ruta completa, por lo que B<-S> le dice a Perl que busque el programa, si es necesario.  Después de localizar el programa, Perl analiza las líneas y las ignora porque la variable $ejecutando_bajo_algun_shell no es verdadera.  Si el programa será interpretado por csh, tendrá que reemplazar C<${1+"$@"}> por C<$*>, incluso aunque esto no interprete los espacios incrustados (y cosas así) en la lista de argumentos.  Para poner en marcha I<sh> en lugar de I<csh>, algunos sistemas pueden tener que reemplazar la línea C<#!> con una línea que contenga sólo un carácter de dos puntos, que será amablemente ignorado por Perl.  Otros sistemas no controlan nada de esto, y necesitan de una enrevesada construcción que funcione tanto en I<csh>, como I<sh> o Perl, tales como la siguiente:

	eval '(exit $?0)' && eval 'exec perl -wS $0 ${1+"$@"}'
	& eval 'exec /usr/bin/perl -wS $0 $argv:q'
		if $ejecutando_bajo_algun_shell;

Si el nombre del archivo suministrado contiene separadores de directorios (y por lo tanto es una ruta absoluta o relativa), y si ese archivo no es encontrado, las plataformas que añaden extensiones de archivo lo harán, y tratarán de buscar el archivo con estas extensiones añadidas, una a una.

En plataformas DOS, si el programa no contiene separadores de directorios, en primer lugar se buscará en el directorio actual antes de ser buscado en el PATH.  En plataformas Unix, el programa se buscará estrictamente en PATH.

=item B<-t>
X<-t>

Al igual que B<-T>, pero las comprobaciones de contaminación emitirán advertencias en lugar de errores fatales.  Estas advertencias se pueden controlar de forma normal con C<no warnings qw(taint)>.

B<Nota: ¡Esto no es un sustituto de C<-T>!> Su destino es ser utilizada I<sólo> como una ayuda temporal para el desarrollo, mientras asegura código heredado: para el código en producción real y para nuevo código seguro escrito desde cero, utilice siempre el verdadero B<-T>.

=item B<-T>
X<-T>

activa el modo "contaminación" para que pueda probarlo.  Por lo general, estos controles se realizan sólo cuando se ejecuta setuid o setgid.  Es una buena idea activarlo de forma explícita en los programas que se ejecutan en nombre de otra persona que no sea, necesariamente, de su confianza, tales como programas CGI o cualquier servidor de Internet que se puede escribir en Perl.  Vea L<perlsec> para más detalles.  Por razones de seguridad, esta opción debe ser vista por Perl lo más pronto posible, por lo general esto significa que debe aparecer lo primero en la línea de comandos o en la línea C<#!> en los sistemas que soportan esta construcción.

=item B<-u>
X<-u>

Esta opción hace que Perl vuelque su memoria después de compilar el programa.  A continuación, puede, en teoría, tomar ese volcado de memoria y convertirlo en un archivo ejecutable mediante el uso del programa I<undump> (no suministrado).
Esto acelera el inicio a costa de espacio en disco (que puede minimizar mediante la eliminación de símbolos en el ejecutable).  (Sin embargo, un ejecutable "hola mundo" ocupa unos 200Kb en mi máquina).  Si desea ejecutar una parte de su programa antes del volcado de memoria, use en su lugar el operador dump().  Nota: La disponibilidad de I<undump> es específico de la plataforma y puede no estar disponible para una determinada adaptación de Perl.

=item B<-U>
X<-U>

permite a Perl hacer operaciones inseguras.  En la actualidad las únicas operaciones "no seguras" son las tratan de eliminar directorios mientras se ejecuta como superusuario y ejecutar programas setuid con comprobaciones fatales de contaminación convertidas en advertencias.
Tenga en cuenta que las advertencias deben estar habilitadas con esta opción para I<generar> realmente las advertencias de contaminación.

=item B<-v>
X<-v>

imprime la versión y nivel de parcheado del ejecutable perl.

=item B<-V>
X<-V>

imprime un resumen de los valores de configuración más importantes de perl y los valores actuales de @INC

=item B<-V:>I<configvar>

Imprime a STDOUT el valor de la(s) variable(s) de configuración indicadas, o múltiples valores cuando el argumento C<I<configvar>> se parece a una expresión regular (no contiene letras).  Por ejemplo:

    $ perl -V:libc
	libc='/lib/libc-2.2.4.so';
    $ perl -V:lib.
	libs='-lnsl -lgdbm -ldb -ldl -lm -lcrypt -lutil -lc';
	libc='/lib/libc-2.2.4.so';
    $ perl -V:lib.*
	libpth='/usr/local/lib /lib /usr/lib';
	libs='-lnsl -lgdbm -ldb -ldl -lm -lcrypt -lutil -lc';
	lib_ext='.a';
	libc='/lib/libc-2.2.4.so';
	libperl='libperl.a';
	....

Además, los caracteres de dos puntos adicionales se pueden utilizar para controlar el formato.  Un carácter dos puntos final suprime el salto de línea y el terminador ";", permitiendo integrar consultas en comandos shell.  (nemotécnico: separador ":" en PATH).

    $ echo "¡ var. compresión: " `perl -V:z.*: ` " aquí están!"
    ¡ var. compresión:  zcat='' zip='zip'  aquí están!

Un carácter dos puntos precedente elimina la parte "name =" de la respuesta, permitiendo asignar el nombre que necesite.  (nemotécnico: etiqueta vacía)

    $ echo "goodvfork="`./perl -Ilib -V::usevfork`
    goodvfork=false;

Caracteres dos puntos precedentes y finales puedes ser usados conjuntamente si necesita valores de parámetros posicionales sin los nombres.  Note que, en el caso siguiente, los parámetros C<PERL_API> se devuelven en orden alfabético.

    $ echo generado_ahora_en `perl -V::osname: -V::PERL_API_.*:`
    generado_ahora_en 'linux' '5' '1' '9'

=item B<-w>
X<-w>

imprime advertencias sobre construcciones dudosas, como nombres de variables mencionadas sólo una vez y variables escalares utilizadas antes de ser declaradas; subrutinas redefinidas; referencias a identificadores de archivo indefinidos; identificadores de archivo abiertos en sólo lectura mientras que está intentando escribir en ellos; valores utilizados como un número que no I<parecen> números; utilizando un array como si se tratara de un escalar; si sus subrutinas tienen más de 100 niveles de profundidad de recursión; y un sinnúmero de otras cosas.

Esta opción, en realidad, sólo activa la variable global C<$^W>; normalmente, es preferible usar el pragma de ámbito léxico C<use warnings>. Puede desactivar o promover en errores fatales, advertencias específicas utilizando enganches C<__WARN__>, como se describe en L<perlvar> y L<perlfunc/warn>.
Vea también L<perldiag> y L<perltrap>.  También está disponible una muy detallada facilidad de advertencias si quiere manipular clases enteras de advertencias; vea L<warnings>.

=item B<-W>
X<-W>

Activa todas las advertencias independientemente de C<no warnings> o C<$^W>.
Vea L<warnings>.

=item B<-X>
X<-X>

Activa todas las advertencias independientemente de C<no warnings> o C<$^W>.
Vea L<warnings>.

=item B<-x>
X<-x>

=item B<-x>I<directorio>

le dice a Perl que el programa está incrustado en un pedazo más grande de texto, sin ninguna relación con él, como por ejemplo, en un mensaje de correo electrónico.  La basura inicial será descartada hasta la primera línea que comience con C<#!> y contenga la cadena "perl".  Se aplicará cualquier opción significativa de esa línea.

Todas las referencias a números de línea en el programa (avisos, errores, ...)
se tratan como si la línea C<#!> fuera la primera.
Entonces, una advertencia en la línea 2 del programa, que está en la línea 100 en el archivo será reportada como la línea 2, no como la línea 100.
Esto se puede anular mediante el uso de la directiva C<#line>.
(Vea L<perlsyn/"Viejos y simples comentarios (¡No!)">)

Si un nombre de directorio es especificado, Perl cambiará a ese directorio antes de ejecutar el programa.  La opción B<-x> controla sólo la eliminación de la basura inicial.  El programa debe terminar con C<__END__> si hay detrás la basura que debe ser ignorada; el programa puede procesar cualquier o toda la basura posterior a través del identificador de archivo C<DATA>, si así lo desea.

El directorio, si se especifica, debe aparecer inmediatamente después de B<-x>, sin espacios en blanco entremedias.

=back

=head1 ENTORNO
X<perl, variables de entorno>

=over 12

=item HOME
X<HOME>

Usada si C<chdir> no tiene argumentos.

=item LOGDIR
X<LOGDIR>

Usada si C<chdir> no tiene argumentos y HOME no está establecida.

=item PATH
X<PATH>

Usada en la ejecución de subprocesos, y en la búsqueda del programa, si se usa B<-S>.

=item PERL5LIB
X<PERL5LIB>

Una lista de directorios en los que buscar archivos de bibliotecas Perl antes de buscar en la biblioteca estándar y en el directorio actual.  Cualesquiera directorios y versiones específicos de la arquitectura, tales como F<version/archname/>, F<version/> o F<archname/> bajo las ubicaciones indicadas, son automáticamente incluidos, si existen, realizando la búsqueda en el arranque del intérprete.  Además, se añade cualquier directorio que coincida con C<$Config{inc_version_list}>.
(Esto sería para ser compatibles con versiones más antiguas de perl instaladas en el mismo árbol de directorio).

Si PERL5LIB no está definido, se usa PERLLIB.  Los directorios están separados (como en PATH) por un carácter dos puntos en las plataformas Unix y por un punto y coma en Windows (el separador de ruta adecuado viene dado por el comando C<perl -V:I<path_sep>>).

Cuando ejecuta test de contaminación, ya sea porque el programa se estaba ejecutando con setuid o setgid, o estaban especificadas las opciones B<-T> o B<-t>, no son consultadas ni PERL5LIB ni PERLLIB. El programa, en su lugar, debería decir:

    use lib "/mi/directorio";

=item PERL5OPT
X<PERL5OPT>

Opciones en línea de comandos.  Las opciones en esta variable son tratadas como si estuvieran en cada línea de comandos Perl.  Solo se permiten las opciones B<-[CDIMUdmtwW]>.  Cuando se ejecutan test de contaminación (ya sea porque el programa se estaba ejecutando setuid o setgid, o especificadas las opciones B<-T> o B<-t>), esta variable es ignorada.  Si PERL5OPT comienza con B<-T>, la contaminación se activa, y se ignoran las opciones siguientes.  Si PERL5OPT comienza con B<-t>, la contaminación será activada, un modificable punto eliminado de @INC, y las posteriores opciones tenidas en cuenta.

=item PERLIO
X<PERLIO>

Una lista separada por espacios (o caracteres de dos puntos) de capas PerlIO. Si perl está compilado para utilizar el sistema de PerlIO de E/S (por defecto) estas capas afectan a la E/S de Perl.

Lo normal es empezar los nombres de capa con un carácter dos puntos (por ejemplo, C<:perlio>) para enfatizar su similitud con la variable "attributes". Sin embargo, el código que analiza cadenas de capas de especificación, que también se utiliza para decodificar la variable de entorno PERLIO, trata al carácter dos puntos como un separador.

Un inexistente PerlIO, o vacío, es equivalente al conjunto predeterminado de capas para su plataforma; por ejemplo, C<:unix:perlio> en sistemas tipo Unix y C<:unix:crlf> en Windows y otros sistemas DOS.

La lista se convierte en el valor predeterminado para I<toda> E/S de Perl. En consecuencia, sólo capas predefinidas en el código pueden aparecer en esta lista, ya que las capas externas (tales como C<encoding()>) ¡necesitan de E/S para poder leerse!  Vea L<"open pragma"|open> para saber cómo añadir codificaciones externas por defecto.

Capas que tiene sentido incluir en la variable de entorno PERLIO se resumen a continuación. Para más detalles, vea L<PerlIO>.

=over 8

=item :bytes
X<:bytes>

Una pseudocapa que pone el indicador C<:utf8> a I<off> para la capa inferior; poco probable que sea útil por sí sola en la variable de entorno global PERLIO.
Quizás estaba pensando en C<:crlf:bytes> o C<:perlio:bytes>.

=item :crlf
X<:crlf>

Una capa que pone CRLF a C<"\n"> trasladando la distinción de los archivos de "texto" y "binarios", a la manera de MS-DOS y sistemas operativos similares.
(En la actualidad, I<no> imita a MS-DOS en cuanto al tratamiento de Control-Z como un marcador de fin de archivo).

=item :mmap
X<:mmap>

Una capa que implementa la "lectura" de archivos mediante el uso de I<mmap>(2) para hacer que todo un archivo aparezca en el espacio de direcciones del proceso, y luego utilizarlo como un búfer de PerlIO.

=item :perlio
X<:perlio>

Esta es una reimplementación del almacenamiento en búfer al estilo stdio escrito como una capa PerlIO.  Como tal será llamada cualesquiera capa esté por debajo de ella, para sus operaciones, por lo general, C<:unix>.

=item :pop
X<:pop>

Una pseudocapa experimental que elimina la capa superior.
Se usa con el mismo cuidado que se reserva para la nitroglicerina.

=item :raw
X<:raw>

Una pseudocapa que manipula las otras capas.  Aplicando la capa C<:raw> es equivalente a llamar a C<binmode($fh)>.  Hace pasar el flujo de cada byte tal cual, sin traducción.  En particular, tanto la traducción de CRLF y la intuición de C<:utf8> desde la configuración regional, son desactivados.

A diferencia de versiones anteriores de Perl, C<:raw> I<no> es justo la inversa de C<:crlf>: otras capas que podrían afectar a la naturaleza binaria del flujo también son eliminadas o desactivadas.

=item :stdio
X<:stdio>

Esta capa proporciona una interfaz PerlIO envolviendo a llamadas a la biblioteca del sistema ANSI C "stdio". La capa proporciona un sistema de búfer y E/S.
Tenga en cuenta que la capa C<:stdio> I<no> hace traducción CRLF incluso si ese es el comportamiento normal de la plataforma. Necesitará una capa C<:crlf> por encima de ella, para hacer eso.

=item :unix
X<:unix>

Capa de bajo nivel que llama a C<read>, C<write>, C<lseek>, etc.

=item :utf8
X<:utf8>

Una pseudocapa que activa un indicador en la capa inferior para avisar a Perl que la salida debe ser en utf8 y que la entrada debe ser considerada como que ya está en una forma válida de utf8. B<AVISO: no comprueba la validez y debe ser gestionada con extrema cautela para la entrada, debido a que pueden ocurrir violaciones de seguridad, con codificaciones UTF-8 no acortadas, etc.> Por lo general, C<:encoding(utf8)> es la mejor opción al leer datos codificados en UTF-8.

=item :win32
X<:win32>

En plataformas Win32 esta capa I<experimental> usa "identificadores" de E/S nativos en lugar de una capa de descriptor de archivo numérico tipo Unix. Se sabe que tiene errores en esta versión (5.14).

=back

El conjunto predeterminado de capas debería dar resultados aceptables en todas las plataformas

Para plataformas Unix esto será equivalente a "unix perlio" o "stdio".
Configure está configurado para preferir el "stdio" si la biblioteca del sistema proporciona un acceso más rápido al búfer; de lo contrario, se utiliza el "unix perlio" de la implementación.

En Win32 el valor por defecto en esta versión (5.14) es "unix crlf". El "stdio" de Win32 tiene una serie de errores/fallas en PerlIO que son un poco dependientes de la versión y del proveedor del compilador de C. Usando nuestra propia capa C<crlf> como búfer, evita estos problemas y hace las cosas más uniformes.  La capa C<crlf> proporciona la conversión CRLF, así como almacenamiento en búfer.

Esta versión (5.14) utiliza C<unix> como la capa inferior de Win32, por lo que todavía utiliza las rutinas de descriptor numérico de archivo del compilador de C. Existe una capa experimental nativa C<win32>, que se espera que sea mejor y, finalmente, deba ser el valor por defecto en Win32.

La variable de entorno PERLIO es completamente ignorada cuando Perl se ejecuta en el modo de contaminación.

=item PERLIO_DEBUG
X<PERLIO_DEBUG>

Si se establece al nombre de un archivo o dispositivo, ciertas operaciones del subsistema PerlIO se registrarán en ese archivo, que se abre en el modo añadir.
Usos típicos en Unix:

   % env PERLIO_DEBUG=/dev/tty perl script ...

y bajo Win32, el equivalente aproximado es:

   > set PERLIO_DEBUG=CON
   perl script ...

Esta funcionalidad está deshabilitada para scripts setuid y para scripts que se ejecuten con B<-T>.

=item PERLLIB
X<PERLLIB>

Una lista de directorios en los que buscar archivos de bibliotecas Perl antes de buscar en la biblioteca estándar y en el directorio actual.
Si PERL5LIB está definida, PERLLIB no se utiliza.

La variable de entorno PERLLIB es completamente ignorada cuando Perl se ejecuta en el modo de contaminación.

=item PERL5DB
X<PERL5DB>

El comando usado para cargar el código del depurador.  El valor por defecto es:

	BEGIN { require "perl5db.pl" }

La variable de entorno PERL5DB sólo se usa cuando Perl es iniciado con una simple opción B<-d>.

=item PERL5DB_THREADED
X<PERL5DB_THREADED>

Si se establece a un valor verdadero, indica al depurador que el código que se está depurando usa hilos de ejecución.

=item PERL5SHELL (específico a la adaptación Win32)
X<PERL5SHELL>

En las adaptaciones Win32, se puede establecer un shell alternativo que Perl debe utilizar internamente para la ejecución de comandos en "comillas invertidas" o system().  Por defecto es C<cmd.exe /x/d/c> en Windows NT y C<command.com /c> en Windows 95.  El valor es considerado que está separado por espacios.  Preceda cualquier carácter que necesite ser protegido, como un espacio o una barra diagonal inversa, con otra barra diagonal inversa.

Tenga en cuenta que Perl no utiliza COMSPEC para este propósito porque COMSPEC tiene un alto grado de variabilidad entre los usuarios, lo que se traduce en problemas de portabilidad.  Además, Perl puede utilizar un shell que no pueda ser apto para el uso interactivo, y el establecimiento de COMSPEC a un shell puede interferir con el buen funcionamiento de otros programas (que sí suelen mirar en COMSPEC para encontrar un shell para el uso interactivo).

Antes de Perl 5.10.0 y 5.8.8, PERL5SHELL no era comprobada su contaminación cuando se ejecutaban comandos externos.  Se recomienda que se establezca explícitamente (o elimine) C<$ENV{PERL5SHELL}> cuando se ejecute en modo contaminación en Windows.

=item PERL_ALLOW_NON_IFS_LSP (específico a la adaptación Win32)
X<PERL_ALLOW_NON_IFS_LSP>

Se establece en 1 para permitir el uso de LSP (proveedores de servicio en niveles) no compatibles con IFS.
Perl normalmente busca un LSP compatible IFS, porque es necesario para la emulación de los I<sockets> de Windows como identificadores de archivo real.  Sin embargo, esto puede causar problemas si usted tiene un cortafuegos como I<McAfee Guardian>, que requiere que todas las aplicaciones utilicen su LSP, pero que no es compatible con IFS, porque es evidente que Perl normalmente evita el uso de ese LSP.

Al establecer esta variable de entorno a 1 significa que Perl simplemente utilizará el primer LSP adecuado, enumerado en el catálogo, que mantenga I<McAfee Guardian> feliz -y en ese caso en particular, Perl también funciona porque el LSP de I<McAfee Guardian> realmente juega a otros juegos que permiten trabajar a las aplicaciones que requieran compatibilidad IFS-.

=item PERL_DEBUG_MSTATS
X<PERL_DEBUG_MSTATS>

Sólo es relevante si Perl es compilado con el C<malloc> incluido con la distribución de Perl; es decir, si C<perl -V:d_mymalloc> está "I<define>" (definido).

Si está establecido, vuelca estadísticas de memoria después de la ejecución.  Si se define a un entero mayor que uno, también vuelca las estadísticas de la memoria después de la compilación.

=item PERL_DESTRUCT_LEVEL
X<PERL_DESTRUCT_LEVEL>

Sólo es relevante si el ejecutable Perl fue compilado con B<-DDEBUGGING>, éste controla el comportamiento de la destrucción global de objetos y otras referencias.  Vea L<perlhacktips/PERL_DESTRUCT_LEVEL> para más información.

=item PERL_DL_NONLAZY
X<PERL_DL_NONLAZY>

Se establece en C<"1"> para hacer que Perl resuelva I<todos> los símbolos indefinidos cuando se cargue una biblioteca dinámica.  El comportamiento por defecto es resolver los símbolos cuando son utilizados.  Establecer esta variable es útil durante las pruebas de las extensiones, ya que asegura que obtendrá un error con nombres de función mal escritos, incluso si el conjunto de pruebas no los llama.

=item PERL_ENCODING
X<PERL_ENCODING>

Si se utiliza el pragma C<use encoding> sin un nombre de codificación explícito, la variable de entorno PERL_ENCODING es consultada por un nombre de codificación.

=item PERL_HASH_SEED
X<PERL_HASH_SEED>

(Desde Perl 5.8.1, nuevas semánticas en Perl 5.18.0) Se usa para reescribir la aleatorización de la función hash interna de Perl. El valor se expresa en hexadecimal, y puede incluir un 0x inicial. Los patrones truncados se tratan como si tuvieran suficientes 0 por detrás.

Si se indica esa opción, y C<PERL_PERTURB_KEYS> no está inicializado, entonces un valor de '0' implica que C<PERL_PERTURB_KEYS=0> y cualquier otro valor implica que C<PERL_PERTURB_KEYS=2>.

B<POR FAVOR, TENGA EN CUENTA: La semilla hash es información sensible>. Los hash son asignados al azar para protegerse contra los ataques locales y remotos contra el código Perl. Poniendo manualmente una semilla, esta protección puede quedar parcial o completamente perdida.

Vea L<perlsec/"Ataques de Complejidad Algorítmica">, L</PERL_PERTURB_KEYS> y L</PERL_HASH_SEED_DEBUG>, para más información.

=item PERL_PERTURB_KEYS
X<PERL_PERTURB_KEYS>

(A partir de Perl 5.18.0) Poniéndolo a C<"0"> o C<"NO">, pasar por las claves será repetible de ejecución en ejecución, para el mismo valor de PERL_HASH_SEED.
La inserción en un hash no cambiará el orden, excepto para proporcionar más espacio en el hash. Cuándo se combina con PERL_HASH_SEED, lo que se consigue es un comportamiento pre-5.18.

Cuando se inicializa a C<"1"> o C<"RANDOM">, entonces pasar por las claves será de forma aleatoria.
Cada vez que se inserte en un hash, el orden de las claves cambiará de forma aleatoria. El orden puede no ser repetible en una siguiente ejecución del programa incluso si se ha especificado PERL_HASH_SEED. Este es el modo por defecto, para *perl.

Cuando se inicializa a C<"2"> o C<"DETERMINISTIC"> entonces insertar claves en un hash provocará que el orden de las claves cambie, pero en una manera que es repetible entre varias ejecuciones del programa.

B<NOTA:> El uso de esta opción se considera insegura, y se pretende que sirva para depurar el comportamiento no determinista de la función hash de Perl. No lo use en producción.

Vea L<perlsec/"Ataques de Complejidad Algorítmica">, L</PERL_HASH_SEED> y L</PERL_HASH_SEED_DEBUG>, para más información. Puede obtener e inicializar la máscara del modo de paso de las claves para un hash específico usando la función C<hash_traversal_mask()>, de L<Hash::Util>.

=item PERL_HASH_SEED_DEBUG
X<PERL_HASH_SEED_DEBUG>

(Desde Perl 5.8.1.)  Poner a C<"1"> para mostrar (en STDERR) información sobre la función hash, la semilla, y qué tipo de paso aleatorio por las claves está activado al comienzo de la ejecución.  Esto, combinado con L</PERL_HASH_SEED> y L</PERL_PERTURB_KEYS> se destina a ayudar en la depuración del comportamiento no determinista causado por la aleatorización de los hash.

B <Note> que cualquier información sobre la función hash, especialmente la semilla hash, es B<información sensible>: conociéndolo, se puede elaborar un ataque de denegación de servicio contra el código Perl, incluso remotamente; vea L<perlsec/"Ataques de Complejidad Algorítmica"> para más información. B<No muestre la semilla hash> a personas que no necesiten conocerla. Vea también C<hash_seed()> y C<key_traversal_mask()> en L<Hash::Util>.

Un de ejemplo de la salida podría ser:

    HASH_FUNCTION = ONE_AT_A_TIME_HARD HASH_SEED = 0x652e9b9349a7a032 PERTURB_KEYS = 1 (RANDOM)

=item PERL_MEM_LOG
X<PERL_MEM_LOG>

Si su Perl se ha compilado con B<-Accflags=-DPERL_MEM_LOG>, poniendo la variable de entorno C<PERL_MEM_LOG> permite el registro de mensajes de depuración. El valor tiene la forma C<< <I<número>>[m][s][t] >>, donde C<I<número>> es el número de descriptor de archivo en donde desea escribir (2, por defecto), y la combinación de letras especifica que desea información acerca de (m)moria y/o (s)v, opcionalmente con (t)iempos. Por ejemplo, C<PERL_MEM_LOG=1mst> registra toda la información a la salida estándar. Puede escribir a otros descriptores de archivo abiertos en una variedad de formas:

  $ 3>foo3 PERL_MEM_LOG=3m perl ...

=item PERL_ROOT (específico a la adaptación VMS)
X<PERL_ROOT>

Solo para VMS, un nombre lógico que hace referencia a la raíz y dispositivo lógico para la ruta @INC.  Otros nombres lógicos que afectan a Perl en VMS incluyen a PERLSHR, PERL_ENV_TABLES y SYS$TIMEZONE_DIFFERENTIAL, pero son opcionales y se explican más adelante en L<perlvms> y en F<README.vms> en la distribución del código fuente de Perl.

=item PERL_SIGNALS
X<PERL_SIGNALS>

Disponible en Perls 5.8.1 y versiones posteriores.  Si se establece a C<"unsafe">, se restaura el comportamiento de señales como en pre-Perl-5.8.0 (que es rápido, pero inseguro).  Si se establece a C<safe>, entonces se usan señales seguras (pero diferidas).  Vea L<perlipc/"Señales Diferidas (Señales Seguras)">.

=item PERL_UNICODE
X<PERL_UNICODE>

Equivalente a la opción de línea de comandos B<-C>.  Tenga en cuenta que esto no es una variable booleana. Definiendo este valor a C<"1">, no es la manera correcta de "activar Unicode" (sea lo que signifique).  Al contrario, puede utilizar C<"0"> para "desactivar Unicode" (o, alternativamente, limpiar PERL_UNICODE en su shell antes de iniciar Perl).  Vea la descripción de la opción B<-C> para más información sobre esto.

=item SYS$LOGIN (específico de la adaptación a VMS)
X<SYS$LOGIN>

Usada si chdir no tiene argumento y HOME y LOGDIR no tienen ningún valor.

=back

Perl también tiene variables de entorno que controlan cómo Perl trata los datos específicos de los lenguajes naturales; vea L<perllocale>.

Perl y sus diferentes módulos y componentes, incluidos los marcos de prueba, a veces pueden hacer uso de ciertas variables de entorno.  Algunos de estos son específicos para una determinada plataforma.  Por favor, consulte la documentación del módulo correspondiente y toda la documentación para su plataforma (como L<perlsolaris>, L<perllinux>, L<perlmacosx>, L<perlwin32>, etc) para las variables propias de esas situaciones específicas.

Perl hace disponibles todas las variables de entorno para el programa en ejecución, y las pasa a todos los procesos hijo que inicie.
Sin embargo, en la ejecución de programas setuid harían bien en ejecutar las siguientes líneas antes de hacer nada, solo para que la gente siga siendo honesta:

    $ENV{PATH}  = "/bin:/usr/bin";    # o lo que sea necesario
    $ENV{SHELL} = "/bin/sh" if exists $ENV{SHELL};
    delete @ENV{qw(IFS CDPATH ENV BASH_ENV)};
